// Code generated by BobGen sqlite v0.28.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/sqlite"
	"github.com/stephenafamo/bob/dialect/sqlite/dialect"
)

var TableNames = struct {
	AipReplications string
	Aips            string
	Errors          string
	Events          string
}{
	AipReplications: "aip_replication",
	Aips:            "aips",
	Errors:          "errors",
	Events:          "events",
}

var ColumnNames = struct {
	AipReplications aipReplicationColumnNames
	Aips            aipColumnNames
	Errors          errorColumnNames
	Events          eventColumnNames
}{
	AipReplications: aipReplicationColumnNames{
		ID:           "id",
		AipID:        "aip_id",
		LocationUUID: "location_uuid",
		ReplicaUUID:  "replica_uuid",
		Status:       "status",
		Attempt:      "attempt",
	},
	Aips: aipColumnNames{
		ID:              "id",
		UUID:            "uuid",
		Status:          "status",
		Found:           "found",
		FixityRun:       "fixity_run",
		Moved:           "moved",
		Cleaned:         "cleaned",
		Replicated:      "replicated",
		ReIndexed:       "re_indexed",
		CurrentLocation: "current_location",
		Size:            "size",
		LocationUUID:    "location_uuid",
	},
	Errors: errorColumnNames{
		ID:      "id",
		AipID:   "aip_id",
		MSG:     "msg",
		Details: "details",
	},
	Events: eventColumnNames{
		ID:                       "id",
		AipID:                    "aip_id",
		Action:                   "action",
		TimeStarted:              "time_started",
		TimeEnded:                "time_ended",
		TotalDuration:            "total_duration",
		TotalDurationNanoseconds: "total_duration_nanoseconds",
		Details:                  "details",
	},
}

var (
	SelectWhere = Where[*dialect.SelectQuery]()
	InsertWhere = Where[*dialect.InsertQuery]()
	UpdateWhere = Where[*dialect.UpdateQuery]()
	DeleteWhere = Where[*dialect.DeleteQuery]()
)

func Where[Q sqlite.Filterable]() struct {
	AipReplications aipReplicationWhere[Q]
	Aips            aipWhere[Q]
	Errors          errorWhere[Q]
	Events          eventWhere[Q]
} {
	return struct {
		AipReplications aipReplicationWhere[Q]
		Aips            aipWhere[Q]
		Errors          errorWhere[Q]
		Events          eventWhere[Q]
	}{
		AipReplications: buildAipReplicationWhere[Q](AipReplicationColumns),
		Aips:            buildAipWhere[Q](AipColumns),
		Errors:          buildErrorWhere[Q](ErrorColumns),
		Events:          buildEventWhere[Q](EventColumns),
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]
	UpdateJoins = getJoins[*dialect.UpdateQuery]
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	AipReplications joinSet[aipReplicationJoins[Q]]
	Aips            joinSet[aipJoins[Q]]
	Errors          joinSet[errorJoins[Q]]
	Events          joinSet[eventJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		AipReplications: buildJoinSet[aipReplicationJoins[Q]](AipReplicationColumns, buildAipReplicationJoins),
		Aips:            buildJoinSet[aipJoins[Q]](AipColumns, buildAipJoins),
		Errors:          buildJoinSet[errorJoins[Q]](ErrorColumns, buildErrorJoins),
		Events:          buildJoinSet[eventJoins[Q]](EventColumns, buildEventJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}
